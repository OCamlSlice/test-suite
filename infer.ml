(* OCaml module generated by the BNF converter *)

type rIdent = RIdent of string
and atom = Atom of string
and program =
   Prog of proc list

and proc =
   Proc of rIdent * pat * com list * pat

and com =
   CAsn of rIdent * exp
 | CRep of pat * pat
 | CCond of exp * thenBranch * elseBranch * exp
 | CLoop of exp * doBranch * loopBranch * exp
 | CShow of exp

and thenBranch =
   BThen of com list
 | BThenNone

and elseBranch =
   BElse of com list
 | BElseNone

and doBranch =
   BDo of com list
 | BDoNone

and loopBranch =
   BLoop of com list
 | BLoopNone

and exp =
   ECons of exp * exp
 | EHd of exp
 | ETl of exp
 | EEq of exp * exp
 | EAnd of exp * exp
 | EVar of variable
 | EVal of valT

and pat =
   PCons of pat * pat
 | PVar of variable
 | PAtom of atom
 | PNil
 | PCall of rIdent * pat
 | PUncall of rIdent * pat

and valT =
   VNil
 | VAtom of atom
 | VCons of valT * valT

and variable =
   Var of rIdent



type t = 
  | Nil
  | Cons of t * t
  | Vars of string
  | Or of (t * bool) list
  | Atom of string
  | Any

type rIdent2 = RIdent2 of string
and atom2 = Atom2 of string
and program2 =
   Prog2 of proc2 list

and proc2 =
   Proc2 of rIdent2 * pat2 * com2 list * pat2

and com2 =
   CAsn2 of rIdent2 * exp2
 | CCall2 of rIdent2 * rIdent2 * pat2
 | CUncall2 of rIdent2 * rIdent2 * pat2
 | CRep2 of pat2 * pat2
 | CCond2 of exp2 * com2 list * com2 list * exp2
 | CLoop2 of exp2 * com2 list * exp2

and exp2 =
   ECons2 of rIdent2 * rIdent2 
 | EHd2 of rIdent2 
 | ETl2 of rIdent2 
 | EEq2 of exp2 * exp2
 | EAnd2 of exp2 * exp2 
 | EVar2 of variable2
 | ENil2
 | EAtom2 of rIdent2 

and pat2 =
   PCons2 of pat2 * pat2
 | PVar2 of variable2
 | PAtom2 of atom2
 | PNil2
 | PCall2 of rIdent2 * pat2
 | PUncall2 of rIdent2 * pat2

and variable2 =
   Var2 of rIdent2

type env = (rIdent2 * t * bool) list

exception Pattern_Match_Error
exception Pattern_Match_Error2

type result = OK
            | NG
            | Dontknow;;

let get exp = match exp with
  | EVar(Var(RIdent(v))) -> RIdent2(v)
  | _ -> (print_string "kkkk"; assert false) in

let rec exp_to_exp2 exp = match exp with
  | ECons(e1, e2) ->
     ECons2(get e1, get e2)
  | EHd(e) ->
     EHd2(get e)
  | ETl(e) ->
     ETl2(get e)
  | EEq(e1, e2) ->
     EEq2(exp_to_exp2 e1, exp_to_exp2 e2)
  | EAnd(e1, e2) -> EAnd2(exp_to_exp2 e1, exp_to_exp2 e2)
  | EVar(Var(RIdent(v))) -> EVar2(Var2(RIdent2(v)))
  | EVal(VNil) -> ENil2 in

let rec pat_to_pat2 p = match p with 
  | PCons(p1, p2) -> PCons2(pat_to_pat2 p1, pat_to_pat2 p2)
  | PVar(Var(RIdent(s))) -> PVar2(Var2(RIdent2(s)))
  | PAtom(Atom(st)) -> PAtom2(Atom2(st))
  | PNil -> PNil2
  | PCall((RIdent(v)), p) -> PCall2((RIdent2(v)), pat_to_pat2 p)
  | PUncall((RIdent(v)), p) -> PUncall2((RIdent2(v)), pat_to_pat2 p) in


let rec com_to_com2 com = 
match com with
  | CAsn(RIdent(v), e) -> CAsn2(RIdent2(v), exp_to_exp2 e)
  | CRep(PVar(Var(RIdent(v))), PCall(RIdent(v2), p)) -> CCall2(RIdent2(v), RIdent2(v2), pat_to_pat2 p)
  | CRep(PVar(Var(RIdent(v))), PUncall(RIdent(v2), p)) -> CUncall2(RIdent2(v), RIdent2(v2), pat_to_pat2 p)
  | CRep(PCall(RIdent(v2), p), (PVar(Var(RIdent(v)))))-> CUncall2(RIdent2(v), RIdent2(v2), pat_to_pat2 p)
  | CRep(PUncall(RIdent(v2), p), (PVar(Var(RIdent(v))))) -> CCall2(RIdent2(v), RIdent2(v2), pat_to_pat2 p)
  | CRep(p1, p2) ->
     CRep2(pat_to_pat2 p1, pat_to_pat2 p2)
  | CCond(e1, BThen(cms1), BElse(cms2), e2) ->
     CCond2(exp_to_exp2 e1, List.map com_to_com2 cms1, List.map com_to_com2 cms2, exp_to_exp2 e2)
  | _ -> assert false
in


let rec proc_to_proc2 prog = match prog with
  | Proc(RIdent(st), p1, coms, p2) ->
     Proc2(RIdent2(st), pat_to_pat2 p1, List.map com_to_com2 coms, pat_to_pat2 p2)
      
     in

let prog_to_prog2 prog = match prog with
  | Prog(procs) -> 
     
     Prog2(List.concat (List.map (fun p -> 
                                   let (Proc(RIdent(st), p1, coms, p2)) = 
                                     assert false in
                                   proc_to_proc2 p :: (* proc_to_proc2 (Proc(RIdent(st ^ "_inv"), p1, coms, p2)) :: *) []) procs))

in


(* normalizing *)

let rec fv_pat p = match p with
  | PCons2(p1, p2) -> (fv_pat p1) @ (fv_pat p2)
  | PVar2(Var2(r)) -> [r]
  | PAtom2(_) -> []
  | PNil2 -> []
  | PUncall2(r, p) -> [r] @ (fv_pat p)
  | PCall2(r, p) -> [r] @ (fv_pat p) in

  (* for search cond *)
let rec fvs_exp exp = match exp with
  | ENil2  | EAtom2(_) -> []
  | ECons2(r1, r2) -> [r1; r2]
  | EHd2(r1) | ETl2(r1) -> [r1]
  | EEq2(e1, e2) | EAnd2(e1, e2) -> (fvs_exp e1) @ (fvs_exp e2)
  | EVar2(Var2(r)) -> [r] in

  (* for search cond *)
let rec fvs_coms coms = match coms with
  | [] -> []
  | CRep2(p1, p2) :: rest -> 
     (fv_pat p1) @ (fv_pat p2) @ (fvs_coms rest)
  | _ :: rest -> fvs_coms rest in
 
let counter = ref 0 in

let gen_name f = 
  let func f = 
    let RIdent2(st) = f in
    let t = RIdent2(st ^ (string_of_int !counter)) in
    (counter := !counter + 1;
     t) in
  let RIdent2(st) = f in
  if String.length st > 4
  then if (String.sub st 0 3) = "COM" then
         f
       else func f
  else func f in
        

let rec update_env env f prev = match env with
  | [] -> prev @ [(f, f)]
  | (fst, fst_v) :: rest -> 
     if f = fst 
     then 
       let t = gen_name f in prev @ [(fst, t)] @ rest
     else update_env rest f (prev@[(fst, fst_v)]) in

let update_pat p env = 
  let fvs = fv_pat p in
  let rec loop fvs env = match fvs with
    | [] -> env
    | f :: rest ->
       let env' = update_env env f [] in
       loop rest env' in
  loop fvs env in

let rec apply_r env r = match env with
  | [] -> r
  | (fst, v) :: rest -> if r = fst then v else apply_r rest r in

let rec apply_exp exp env = match exp with
  | ECons2(ri1, ri2) -> ECons2(apply_r env ri1, apply_r env ri2)
  | EHd2(ri) -> EHd2(apply_r env ri)
  | ETl2(ri) -> ETl2(apply_r env ri)
  | EEq2(e1, e2) -> EEq2(apply_exp e1 env, apply_exp e2 env)
  | EVar2(Var2(ri)) -> EVar2(Var2(apply_r env ri))
  | _ -> exp in

let rec normal_pat pat env = match pat with
  | PVar2(Var2(st)) -> (PVar2(Var2(apply_r env st)), env)
  | PCons2(p1, p2) -> let (p1', env') = normal_pat p1 env in
                      let (p2', env') = normal_pat p2 env' in
                      (PCons2(p1', p2'), env')
  | PAtom2(_) | PNil2 -> (pat, env)
  | PCall2(r, p) -> 
     let (p', env') = normal_pat p env in
     (PCall2(r, p'), env')
  | PUncall2(r, p) ->
     let (p', env') = normal_pat p env in
     (PUncall2(r, p'), env') in

let rec compose_env env1 env2 = match env1 with
  | [] -> env2
  | (a, b) :: rest ->
     let (m, env2') = List.partition (fun (k, m) -> a = k) env2 in
     (a, b) :: (compose_env rest env2') in

let rec normal_com com env = match com with 
  | CAsn2(r, e) -> assert false
  | CCall2(r1, r2, p) -> 
     let (p', env') = normal_pat p env in
     let env' = update_env env' r1 env' in
     (CCall2(apply_r env' r1, apply_r env' r2, p'), env')
  | CUncall2(r1, r2, p) -> 
     let (p', env') = normal_pat p env in
     let env' = update_env env' r1 env' in
     (CUncall2(apply_r env' r1, apply_r env' r2, p'), env')     
  | CRep2(p1, p2) -> 
     let (p2', env') = normal_pat p2 env in
     let env' = update_pat p1 env' in
     let (p1', env') = normal_pat p1 env' in
     (CRep2(p1', p2'), env')
  | CCond2(e1, coms1, coms2, e2) ->  
     let e' = apply_exp e1 env in
     let (coms1', env1) = normal_coms coms1 env in
     let (coms2', env2) = normal_coms coms2 env in
     let env' = compose_env env1 env2 in
     (CCond2(e', coms1', coms2', apply_exp e2 env), env')
  | CLoop2(e1, coms, e2) -> assert false

and normal_coms coms env = match coms with
  | [] -> ([], env)
  | fst :: rest ->
     let (com', env') = normal_com fst env in
     let (rest', env'') = (normal_coms rest env') in
     (com' :: rest', env'') in

let rec compose_reps fvs env = match fvs with
  | [] -> (env, [])
  | fst :: rest ->
     let RIdent2(st) = fst in 
     let t = (gen_name (RIdent2("COM" ^ st))) in 
     let (env, rest') = (compose_reps rest env) in
     ((fst, t) :: env, (CRep2(PVar2(Var2(t)), PVar2(Var2(fst)))) :: rest') in


let rec map_com2 com f_r f_e f_p = match com with
  | CAsn2(r, e) -> CAsn2(f_r r, f_e e)
  | CCall2(r1, r2, p) -> CCall2(f_r r1, f_r r2, f_p p)
  | CUncall2(r1, r2, p) ->  CUncall2(f_r r1, f_r r2, f_p p)
  | CRep2(p1, p2) -> 
     CRep2(f_p p1, f_p p2)
  | CCond2(e1, coms1, coms2, e2) ->  
     CCond2(f_e e1, List.map (fun x -> map_com2 x f_r f_e f_p) coms1,
            List.map (fun x -> map_com2 x f_r f_e f_p) coms2, f_e e2)
  | CLoop2(e1, coms, e2) ->
     CLoop2(f_e e1, List.map (fun x -> map_com2 x f_r f_e f_p) coms, f_e e2) in


let rec apply_coms coms env = match coms with
  | [] -> []
  | fst :: rest ->  coms (* map_com2 fst (replace env) (fun x -> x) (fun x -> x)
                          *) in


let rec search_cond coms env = match coms with
  | [] -> ([], env)
  | CCond2(exp1, coms1, coms2, exp2) :: rest -> 
     let fv = fvs_exp exp2 in
     let fvs = fvs_coms rest in
     let (env', reps) = compose_reps (fv @ fvs) [] in
     let (rest', env'') = normal_coms rest env' in
     let (coms, env''') = (search_cond rest' env'') in
     
     (CCond2(exp1, coms1 @ reps, coms2 @ reps, apply_exp exp2 env''') ::
       coms, env''')
  | fst :: rest -> 
     let (rest', env') = (search_cond rest env) in
     (fst :: rest', env') in

let rec normal_proc proc env = match proc with
  | Proc2(st, p1, coms, p2) ->
     let env = update_env env st [] in
     let (coms', env) = search_cond coms env in
     let env' = update_pat p1 env in 

     let (coms', env'') = normal_coms coms' env' in
     let (p2, env'') = normal_pat p2 env' in
     (Proc2(st, p1, coms', p2), env'') in

let normal_prog prog env = match prog with
  | Prog2(procs) -> Prog2(List.map (fun x -> let (a, _) = normal_proc x env in a) procs) in

(* tentative print *)

let print_ri ri = match ri with
  | RIdent2(st) -> st in

let rec print_pat pat = match pat with
  | PCons2(p1, p2) -> "(" ^ (print_pat p1) ^ "." ^ (print_pat p2) ^ ")"
  | PVar2(Var2(RIdent2(st))) -> st
  | PAtom2(Atom2(st)) -> st
  | PNil2 -> "nil"
  | PCall2((RIdent2(st)), p) -> "call " ^ st ^ "(" ^ (print_pat p) ^ ")"
  | PUncall2((RIdent2(st)), p) -> "uncall " ^ st ^ "(" ^ (print_pat p) ^ ")" in

let rec print_exp exp = match exp with 
  | ECons2(r1, r2) -> "(" ^ (print_ri r1) ^ "." ^ (print_ri r2) ^ ")"
  | EHd2(r) -> "hd (" ^ (print_ri r) ^ ")"
  | ETl2(r) -> "tl (" ^ (print_ri r) ^ ")"
  | EEq2(e1, e2) -> "(=? (" ^ (print_exp e1)  ^ ")" ^ "(" ^ (print_exp e2)  ^ "))"
  | EAnd2(e1, e2) -> "(&& (" ^ (print_exp e1)  ^ ")" ^ "(" ^ (print_exp e2)  ^ "))"
  | EVar2(Var2(RIdent2(st))) -> st
  | ENil2 -> "nil"
  | EAtom2(RIdent2(st)) -> st in

let rec print_com com = match com with
  | CAsn2(_) -> assert false
  | CCall2(r1, r2, pat) -> (print_ri r1) ^ "<= "^ "call " ^ (print_ri r2) ^ "(" ^ (print_pat pat) ^ ")"
  | CUncall2(r1, r2, pat) ->(print_ri r1) ^ "<= "^ "uncall " ^ (print_ri r2) ^ "(" ^ (print_pat pat) ^ ")\n"
  | CLoop2(_) -> assert false
  | CRep2(p1, p2) -> (print_pat p1) ^ "<=" ^ (print_pat p2)
  | CCond2(e1, coms1, coms2, e2) ->
     "if " ^ (print_exp e1) ^ "\nthen " ^ 
       (String.concat "\n" (List.map print_com coms1)) ^ "\nelse " ^
         (String.concat "\n" (List.map print_com coms2)) ^ "\n" ^
           "fi " ^ (print_exp e2) ^ "\n" in


let rec print_proc proc = match proc with
  | Proc2(RIdent2(st), p1, coms, p2) ->
     "proc " ^ st ^ "(" ^ (print_pat p1) ^ ")\n"
     ^ (String.concat "\n" (List.map print_com coms)) ^ "return(" ^ (print_pat p2) ^")\n\n" in

let print_prog prog = match prog with
  | Prog2(procs) ->
     List.iter (fun x -> print_string (print_proc x)) procs in



let print_rident r = match r with
  | RIdent2 (st) -> st in

let rec print_t t = match t with
  | Nil -> "nil"
  | Cons(t1, t2) -> "cons(" ^ (print_t t1) ^ "," ^ (print_t t2) ^ ")"
  | Or(ts) -> "Or(" ^ (String.concat ", " (List.map (fun (x, b) -> (print_t x) ^ (string_of_bool b))ts))^ ")"
  | Vars(st) -> "var(" ^ st ^ ")"
  | Any -> "any" in

let rec print_env rts = match rts with
  | [] -> ()
  | (r, t, b) :: rest -> 
     print_string (print_rident r);
     print_string ":";
     print_string (print_t t);
     print_string ":";
     print_string (string_of_bool b);
     print_newline ();
     print_env rest in

let lookup' env x = 
  (try(let (_, m, b) = (List.find (fun (y, e, _)-> x = y) env) in
      (m, b))
       with Not_found -> let RIdent2(x) = x in 
                         print_string x;
                         raise Not_found) in
let lookup env x = 
  let (m, b) = lookup' env x in if b = false then Nil else m in

let rec add env x = match env with
  | [] -> [(x,Any,true)]
  | (x', v, b) :: rest -> if x = x' then env
                      else (x', v, b) :: (add rest x) in

let rec update env x e b' = match env with
  | [] -> [(x, e, b')]
  | (fst, v, b) :: rest ->
     if fst = x then (x, e, b') :: rest (* TODO? *)
     else (fst, v, b) :: (update rest x e b') in

(* pat -> env -> val *)
let rec infer_pat pat = match pat with
  | PVar2(Var2(RIdent2(x))) -> Vars(x)
  | PCons2(p1, p2) -> Cons(infer_pat p1, infer_pat p2)
  | PNil2 -> Nil
  | PAtom2(Atom2(st)) -> Atom(st) in

let rec infer_valt valt = match valt with
  | VNil -> Nil
  | VAtom(Atom(st)) -> assert false
  | VCons(v1, v2) -> Cons(infer_valt v1, infer_valt v2) in


let rec get_value env v = 
  let t = lookup env v in
  (match t with
   | Cons(_) | Any | Nil -> t
   | Vars(st) -> get_value env (RIdent2(st))
   | Or(_) -> assert false
   | _ -> assert false) in

(* exp -> env -> t *)
let rec infer_exp exp env = match exp with
  | ECons2(RIdent2(v1), RIdent2(v2)) -> Cons(Vars(v1), Vars(v2))
  | EHd2(v) -> let t = get_value env v in
              (match t with
               | Cons(v1, v2) -> v1
               | Any -> Any
               | Nil -> raise Pattern_Match_Error2
               | _ -> assert false)
  | ETl2(v) -> let t = get_value env v in
              (match t with
               | Cons(v1, v2) -> v2
               | Any -> Any
               | Nil -> raise Pattern_Match_Error2
               | _ -> assert false)
  | EEq2(e1, e2) -> Or([(infer_exp e1 env, true); (infer_exp e2 env, true)])
  | EVar2(Var2(r1)) -> lookup env r1
  | ENil2 -> Nil
  | EAtom2(RIdent2(v)) -> Atom(v) in
     
(*
let rec compose_env env1 env2 = match (env1, env2) with
  | ((x, t1) :: rest1, (y, t2) :: rest2) ->
     if x = y 
     then if t1 = t2 then (x, t1) :: (compose_env rest1 rest2)
          else (x, Or([(t1, true); (t2, true)])) :: (compose_env rest1 rest2)
     else (x, t1) :: (compose_env rest1 env2)
  | ([], []) -> []
  | _ -> assert false
 *)

let rec used st env = match env with
  | [] -> []
  | (fst, m, true) :: rest -> 
     if (RIdent2(st)) = fst
     then (fst, m, false) :: rest
     else (fst, m, true) :: (used st rest)
  | (fst, m, b) :: rest -> (fst, m, b) :: (used st rest) in
     

let rec infer_rep p v env = match (p, v) with
  | (PVar2(Var2(RIdent2(x))), Vars(st)) -> 
     if (String.length x) > 4 then
       let (m, b) = lookup' env (RIdent2(st)) in
       (update env (RIdent2(x)) v b)
     else 
       let (m, b) = lookup' env (RIdent2(st)) in
       used st (update env (RIdent2(x)) v b)
  | (PVar2(Var2(x)), v) -> update env x v true
  | (PCons2(p1, p2), Cons(t1, t2)) -> (infer_rep p2 t2 (infer_rep p1 t1 env))
  | (PCons2(p1, p2), Any) -> (infer_rep p2 Any (infer_rep p1 Any  env))
  | (PCons2(p1, p2), Vars(st)) ->
      used st (infer_rep p2 Any (infer_rep p1 Any env))
(* (infer_rep p1 (Head(Vars(st)))) @ (infer_rep p2 (Tail(Vars(st)))) *)
  | (PCons2(p1, p2), Nil) -> raise Pattern_Match_Error2
  | (_, Any) -> env (* ?? *)
  | (PCall2(r, p), Vars(st)) -> assert false
  | (PUncall2(r, p), Vars(st)) -> assert false
  | (PNil2, Vars(st)) -> 
     let (m, b) = lookup' env (RIdent2(st)) in 
     update env (RIdent2(st)) Nil b
  | (PAtom2(_), t) -> print_string (print_t t); assert false
  | (_, t) -> print_string (print_t t); assert false in


(* どこか間違ってる *)
let rec merge_env env1 env2 = match env1 with
  | [] -> env2
  | (r, v, b) :: rest ->
     let (l1, l2) = (List.partition (fun (r2, v2, _) -> r = r2) env2) in
     
     try(let (_, m, b2) = List.hd l1 in
         if v = m then (r, v, b && b2) :: (merge_env rest l2)
         else (r, Or([(v, b); (m, b2)]), b || b2) :: (merge_env rest l2))
     with _ -> (r, v, b) :: (merge_env rest l2) in

(* com -> env -> env *)
let rec infer_com com env = 
  match com with
  | CAsn2(r1, e) -> update env r1 (infer_exp e env) true
  | CCall2(r1, RIdent2(st), p) ->
     update env r1 (Vars(st)) true
  | CUncall2(r1, RIdent2(st), p) ->
     update env r1 (Vars(st)) true(* inverse *)
  | CRep2(p1, p2) -> 
     let v2 = infer_pat p2 in
    (* merge_env env *) (infer_rep p1 v2 env)
  | CCond2(e1, c1, c2, e2) -> (* e2 *)
     merge_env (infer_coms c1 env) (infer_coms c2 env)
  | CLoop2(e1, c, e2) -> (infer_coms c env)
(*  | CShow2(_) -> assert false *)

and infer_coms coms env = 
  match coms with
  | [] -> env
  | com :: rest -> infer_coms rest (infer_com com env) in



let rec add_pat pat env = match pat with
  | PCons2(p1, p2) -> (add_pat p1 (add_pat p2 env))
  | PVar2(Var2(v)) -> add env v
  | PAtom2(_) -> env
  | PNil2(_) -> env in



let rec infer_proc (Proc2(ri, pat1, coms, pat2)) env = 
  infer_coms coms (add_pat pat1 ((ri, infer_pat pat2, true)::env)) in


(* program -> env -> env *)
let rec infer_prog prog env = match prog with 
  | Prog2(procs) ->
     let rec loop procs env = match procs with
       | [] -> env
       | fst :: rest -> loop rest (infer_proc fst env) in
     loop procs env in

let rec infer_top prog env = match prog with 
  | Prog2(procs) ->
    infer_prog prog env in

let rec eval_t t env = match t with
  | Nil -> Nil
  | Cons(t1, t2) -> Cons(t1, t2)
  | Vars(st) -> lookup env (RIdent2(st))
  | Or(ts) -> Or(ts)
  | Atom(st) -> Atom(st)
  | Any -> Any
(*
  | Tail(t) -> let t = eval_t t env in
                (match t with
                 | Cons(t1, t2) -> Cons(eval_t t2 env, Nil)
                 | _ -> Tail(t))
  | Head(t) -> let t = eval_t t env in
                (match t with
                 | Cons(t1, t2) -> eval_t t1 env
                 | _ -> Head(t)) in
 *) in

let rec eval_t_top t env = 
  let t' = eval_t t env in
(*  let t' = eval_t t' env in
  let t' = eval_t t' env in
  t' *)
  if t = t' then t
  else eval_t_top t' env in

(* let if_p1 = Head(Tail(Vars("N1")))
let if_p11 = Head(Tail(Vars("N2")))
let if_p2 = Nil *)



let rec check_undefined b env = match b with 
  | Nil | Atom(_) -> true
  | Cons(t1, t2) -> (check_undefined t1 env) && (check_undefined t2 env)
  | Or(ts) -> assert false
  | Any -> false
  | Vars(st) -> check_undefined (lookup env (RIdent2(st))) env in

let check_undefined_all b1 b2 b3 b4 env_then env_else =
  (check_undefined b1 env_then) && (check_undefined b2 env_then) && (check_undefined b3 env_else) && (check_undefined b4 env_else) in

let rec checking env env' prog' = match env with
  | [] -> OK
  | (RIdent2(st) as x, Or(lst), b)::rest ->
     if (String.length st) < 4 then
       checking rest ((x, Or(lst), b) :: env') prog'
     else 
     (match lst with
      | (fst, _) :: (snd, _) :: [] ->
         let env_then = (env' @ [(x, fst, b)] @ rest) in
         let env_else = (env' @ [(x, snd, b)] @ rest) in

         let (Prog2((Proc2(_, _, coms, _))::_)) = prog' in


(* 実際には infinite loop になるかも *)
let rec infer_t t env = match t with 
  | Nil | Cons(_) | Atom(_) | Any -> t
  | Vars(st) -> infer_t (lookup env (RIdent2(st))) env in

let rec infer_exp' exp env = 
  let t = (infer_exp exp env) in
  (match t with
   | Vars(st) -> infer_t (lookup env (RIdent2(st))) env (* もう一段階？ *)
   | _ -> t) in


let rec check_cond coms = match coms with
  | [] -> OK
  | CAsn2(_) :: rest | CCall2(_) :: rest | CUncall2(_) :: rest 
    | CRep2(_) :: rest | CLoop2(_) :: rest -> check_cond rest
  | CCond2(_, _, _, EEq2(e1, e2)) :: rest ->
     let b1 = (infer_exp' e1 env_then) in
     let b2 = (infer_exp' e2 env_then) in
     let b3 = (infer_exp' e1 env_else) in
     let b4 = (infer_exp' e2 env_else) in

     print_string "====";
     print_string (print_t b1);
     print_string "====";
     print_string (print_t b2);
     print_string "====";
     print_string (print_t b3);
     print_string "====";
     print_string (print_t b4);
     flush stdout ;
           if b1 = b2
              && b3 <> b4
           then check_cond rest
           else if check_undefined_all b1 b2 b3 b4 env_then env_else then NG
           else Dontknow

in


print_newline();
print_newline();
print_string "print_env_then";
print_env env_then;
print_newline();
print_newline();
print_string "print_env_else";
print_env env_else;
print_newline();

check_cond coms
           
           
      (*
         let b1 = (eval_t_top if_p1 env_then) in
         let b2 = (eval_t_top if_p2 env_then) in
         let b3 = (eval_t_top if_p11 env_else) in
         let b4 = (eval_t_top if_p2 env_else) in

         print_string "====";
         print_string (print_t b1);
        print_string "====";
         print_string (print_t b2);
        print_string "====";
         print_string (print_t b3);
        print_string "====";
         print_string (print_t b4);
         flush stdout;

         if b1 = b2
            && b3 <> b4
         then checking rest env'
         else if check_undefined_all b1 b2 b3 b4 then NG
         else Dontknow *)
      | _ -> assert false)
  | (x, m, b) :: rest -> checking rest ((x, m, b) :: env') prog'

in 3

